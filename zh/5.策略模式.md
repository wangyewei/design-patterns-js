## 策略模式

​	很多时候，到达同一个目的地会有多种途径，比如要去某地旅游就可以根据实际情况来选择出行的路线：

- 如果预算够可以坐飞机
- 如果不够可以坐大巴或者火车
- 也可以骑自行车

​	在程序设计中，也常常有类似情况，要实现某种功能有多种方案可选。

​	策略模式的定义：*定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换*

### 1. 使用策略模式计算奖金

​	例如，绩效为S的人年终有四个月的工资，A有3个月，B有两个月：

#### 1.1 最简单的实现

```javascript
const caculateBouns = (perfomanceLevel, salary) => {
    if (perfomanceLevel === "S") return salary * 4
    if (perfomanceLevel === "A") return salary * 3
    if (perfomanceLevel === "C") return salary * 2
}

console.log(caculateBouns("A", 20000))
```

​		这段代码虽然简单，但是存在太多缺点：

1. 函数庞大，包含了太多`if-else`语句，这些语句需要覆盖所有的逻辑分支。
2. 函数缺乏弹性，如果想要增加新的绩效，或者绩效奖金系数，那么就要深入函数内部，这是违反「开放-封闭」原则的。
3. 复用性差。

#### 1.2 使用组合函数重构代码

​	可以将各种算法封装到一个小函数里面，这些小函数有良好的命名，可以清楚地看出对应关系，它也可以被复用在其他地方。

```javascript
const performanceS = (salary) => salary * 4
const performanceA = (salary) => salary * 3
const performanceB = (salary) => salary * 2

const caculateBouns = (perfomanceLevel, salary) => {
    if (perfomanceLevel === "S") return performanceS(salary)
    if (perfomanceLevel === "A") return performanceA(salary)
    if (perfomanceLevel === "C") return performanceB(salary)
}

console.log(caculateBouns("A", 20000)) // 60000
```

​	这样得到了一些改善，但是函数还是有可能越来越庞大，而且在系统变化的时候缺乏弹性。

#### 1.3 使用策略模式重构代码

​	一个基于策略模式的程序至少由两部分组成：

1. 一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
2. 环境类context，context接收用户的请求，随后把请求委托给某一个策略类。

​	能做到以上的点，说明context重要维持对某个策略对象的引用：

```javascript
class PerformanceS {
    calculate(salary) {
        return salary * 4
    }
}

class PerformanceA {
    calculate(salary) {
        return salary * 3
    }
}

class PerformanceB {
    calculate(salary) {
        return salary * 2
    }
}

class Bonus {
    constructor() {
        this.salary = null
        this.strategy = null
    }

    setSalary(salary) {
        this.salary = salary
    }

    setStrategy(strategy) {
        this.strategy = strategy
    }

    getBonus() {
        return this.strategy.calculate(this.salary)
    }
}

const bonus = new Bonus()

bonus.setSalary(10000)
bonus.setStrategy(new PerformanceS()) // 设置策略对象
console.log(bonus.getBonus()) // 40000
bonus.setStrategy(new PerformanceA()) // 设置策略对象
console.log(bonus.getBonus()) // 30000
```

​	通过策略模式重构后，代码变得更加清晰，各个类的职责更加鲜明，但这段代码是基于传统面向对象语言的模仿。

### 2. JavaScript版本的策略模式

​	在JavaScript中，函数也是对象，所以更加简洁的做法是把`strategy`直接定义为函数:

```javascript
const strategies = {
    S: (salary) => salary * 4,
    A: (salary) => salary * 3,
    B: (salary) => salary * 2,
}

const caculateBouns = (level, salary) => strategies[level](salary)

console.log(caculateBouns("S", 20000)) // 80000
console.log(caculateBouns("A", 10000)) // 30000
</script>
```

### 3. 多态在策略模式中的体现

​	通过使用策略模式重构代码，消除了原程序中大片的条件分支语句。所有跟计算奖金游馆的逻辑不在放在`Context`中而是分布在各个策略对象中，`Context`并没有计算奖金的能力，而是把这个职责委托给某个策略对象。

### 4. 策略模式实现缓动动画

​	如果明白了怎样让一个小球运动起来，剩下再把逻辑组织起来，那么就离编写游戏不远了，搜先要做的是让一个小球按照不同的算法进行运动：

### 5. 实现动画效果的原理

​	用JavaScript实现动画效果的原理和制作动画片一样，动画片是把一些差距不大的动画以较快的帧数播放，来达到视觉上的动画效果。

​	在JavaScript中，可以通过改变元素的某个`CSS`属性，比如`left`、`top`、`background-position`来实现动画效果。

### 6. 让小球运动起来

​	以下算法都接收4个参数，分别是：`动画已消耗的时间`、`原始位置`、`目标位置`、`动画持续总时间`，返回的值是动画元素`应该处在的当前位置`：

```javascript
const tween = {
    linear: (t, b, c, d) => (c * t) / d + b,
    easeIn: (t, b, c, d) => c * (t /= d) * t + b,
    strongEaseIn: (t, b, c, d) => c * (t /= d) * t * t * t + b,
    strongEaseOut: (t, b, c, d) =>
    c * ((t = t / d - 1) * t * t * t * t + 1),
    sineaseIn: (t, b, c, d) => c * (t /= d) * t * t + b,
    sineaseOut: (t, b, c, d) => c * ((t = t / d - 1) * t * t + 1) + b,
}
```

在页面中放置一个`div`：

```html
<div style="position: absolute; background: blue; color: #fff">A Div</div>
```

定义`Animate`类，它的构造函数接收一个参数：`即将运动起来的dom节点`:

```javascript
class Animate {
    constructor(dom) {
        this.dom = dom
        this.startTime = 0
        this.startPos = 0
        this.endPos = 0
        this.propertyName = null
        this.easing = null
        this.duration = null
    }
}
```

定义`Animate.protptype.start`方法负责启动动画，在动画被启动的瞬间，要记录一些信息供缓动算法计算小球当前未知使用，在记录完这些信息之后，还要负责启动定时器,`Animate.property.step`方法代表小球运动的每一帧要做的事，在此处这个方法负责计算小球当前位置和调用更新`CSS`属性值的方法`Animate.prototype.update`:

```javascript
const tween = {
    linear: (t, b, c, d) => (c * t) / d + b,
    easeIn: (t, b, c, d) => c * (t /= d) * t + b,
    strongEaseIn: (t, b, c, d) => c * (t /= d) * t * t * t + b,
    strongEaseOut: (t, b, c, d) =>
    c * ((t = t / d - 1) * t * t * t * t + 1),
    sineaseIn: (t, b, c, d) => c * (t /= d) * t * t + b,
    sineaseOut: (t, b, c, d) => c * ((t = t / d - 1) * t * t + 1) + b,
}

class Animate {
    constructor(dom) {
        this.dom = dom
        this.startTime = 0
        this.startPos = 0
        this.endPos = 0
        this.propertyName = null
        this.easing = null
        this.duration = null
    }

    start(propertyName, endPos, duration, easing) {
        // 动画启动时间
        this.startTime = +new Date()
        // dom节点初始位置
        this.startPos = this.dom.getBoundingClientRect()[propertyName]
        // 更改的css属性
        this.propertyName = propertyName
        // dom节点目标位置
        this.endPos = endPos
        // 动画持续时间
        this.duration = duration
        // 缓动算法
        this.easing = tween[easing]
        // console.log(this.easing)
        let timeId = setInterval(() => {
            // console.log("ok")
            if (this.step() === false) {
                clearInterval(timeId)
            }
        }, 19)
        }

    step() {
        const t = +new Date()

        if (t >= this.startTime + this.duration) {
            this.update(this.endPos)
            return false
        }

        const pos = this.easing(
            t - this.startTime,
            this.startPos,
            this.endPos - this.startPos,
            this.duration
        )
        this.update(pos)
    }

    update(pos) {
        this.dom.style[this.propertyName] = `${pos}px`
    }
}

const $div = document.getElementsByClassName("div")[0]
const animate = new Animate($div)
animate.start("left", 1500, 500, "strongEaseOut")
```

​	通过使用策略模式把算法传入动画类中，来达到各种不同的缓动效果，这些算法都可以轻易地替换另一个算法，这就是策略模式经典运用之一。

### 6. 更广义的算法